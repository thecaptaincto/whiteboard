<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NoteGrid â€” Study Whiteboard</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=DM+Mono:wght@300;400;500&display=swap');

*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{
  --tb:52px; --lw:56px; --cw:46px; --sw:40px;
  --left: calc(var(--lw) + var(--cw) + var(--sw));
}
body{font-family:'DM Mono',monospace;background:#fff;color:#1a1a1a;overflow:hidden;height:100vh;width:100vw;-webkit-user-select:none;user-select:none}

/* â”€â”€ AUTH â”€â”€ */
#auth{position:fixed;inset:0;background:#fff;display:flex;align-items:center;justify-content:center;z-index:9000}
.abox{width:360px;border:1.5px solid #1a1a1a;padding:36px}
.alogo{font-size:20px;font-weight:500;letter-spacing:-0.5px;margin-bottom:4px}
.atag{font-size:11px;color:#aaa;margin-bottom:26px}
.atabs{display:flex;border-bottom:1.5px solid #1a1a1a;margin-bottom:22px}
.atab{padding:6px 18px;font-family:inherit;font-size:12px;cursor:pointer;border:none;background:none;color:#aaa;letter-spacing:.3px}
.atab.on{background:#1a1a1a;color:#fff}
.afield{margin-bottom:12px}
.afield label{display:block;font-size:10px;letter-spacing:.7px;text-transform:uppercase;color:#aaa;margin-bottom:5px}
.afield input{width:100%;padding:9px 10px;border:1.5px solid #e0e0e0;font-family:inherit;font-size:13px;outline:none;transition:border-color .2s}
.afield input:focus{border-color:#1a1a1a}
.abtn{width:100%;padding:10px;background:#1a1a1a;color:#fff;border:none;font-family:inherit;font-size:12px;letter-spacing:.4px;cursor:pointer;margin-top:6px}
.abtn:hover{background:#333}
.askip{width:100%;padding:9px;background:none;color:#aaa;border:1.5px solid #e0e0e0;font-family:inherit;font-size:11px;cursor:pointer;margin-top:6px}
.askip:hover{border-color:#1a1a1a;color:#1a1a1a}
.aerr{font-size:11px;color:#c00;margin-top:8px;min-height:16px}

/* â”€â”€ TOPBAR â”€â”€ */
#topbar{position:fixed;top:0;left:0;right:0;height:var(--tb);background:#fff;border-bottom:1.5px solid #1a1a1a;display:flex;align-items:center;padding:0 12px;z-index:200;gap:8px;flex-shrink:0}
.logo{font-size:14px;font-weight:500;flex-shrink:0}
.sep{width:1px;height:20px;background:#ddd;flex-shrink:0}
.bname{font-family:inherit;font-size:12px;border:none;border-bottom:1px solid transparent;outline:none;background:transparent;color:#1a1a1a;padding:2px 4px;width:160px;transition:border-color .2s}
.bname:focus{border-bottom-color:#ddd}
.tbtn{padding:5px 10px;background:none;border:1.5px solid #ddd;font-family:inherit;font-size:10px;letter-spacing:.3px;cursor:pointer;color:#1a1a1a;white-space:nowrap;transition:border-color .15s;flex-shrink:0}
.tbtn:hover{border-color:#1a1a1a}
.tbtn.pri{background:#1a1a1a;color:#fff;border-color:#1a1a1a}
.tbtn.pri:hover{background:#333}
.sp{flex:1}
.zd{font-size:10px;color:#aaa;min-width:40px;text-align:center;flex-shrink:0}
.ubadge{font-size:10px;color:#aaa;flex-shrink:0}
.fmodes{display:flex;gap:2px;flex-shrink:0}
.fmbtn{padding:4px 7px;border:1.5px solid #ddd;font-family:inherit;font-size:9px;cursor:pointer;background:none;color:#aaa;transition:all .12s;letter-spacing:.2px}
.fmbtn.on{background:#1a1a1a;color:#fff;border-color:#1a1a1a}

/* â”€â”€ LEFT TOOLBAR â”€â”€ */
#toolbar{position:fixed;left:0;top:var(--tb);bottom:0;width:var(--lw);background:#fff;border-right:1.5px solid #1a1a1a;display:flex;flex-direction:column;align-items:center;padding:8px 0;gap:2px;z-index:150;overflow-y:auto}
.tb{width:40px;height:40px;display:flex;align-items:center;justify-content:center;border:1.5px solid transparent;cursor:pointer;background:none;color:#1a1a1a;font-size:16px;position:relative;transition:all .12s;flex-shrink:0;font-family:inherit}
.tb:hover{border-color:#ddd;background:#f8f8f8}
.tb.on{border-color:#1a1a1a;background:#1a1a1a;color:#fff}
.tsep{width:28px;height:1px;background:#ebebeb;margin:3px 0;flex-shrink:0}
.tip{position:absolute;left:46px;top:50%;transform:translateY(-50%);background:#1a1a1a;color:#fff;font-family:inherit;font-size:10px;padding:3px 8px;pointer-events:none;white-space:nowrap;opacity:0;transition:opacity .12s;z-index:400;letter-spacing:.3px}
.tb:hover .tip{opacity:1}

/* â”€â”€ COLOR PANEL â”€â”€ */
#cpanel{position:fixed;left:var(--lw);top:var(--tb);bottom:0;width:var(--cw);background:#fafafa;border-right:1px solid #e8e8e8;display:flex;flex-direction:column;align-items:center;padding:8px 0;gap:5px;z-index:140;overflow-y:auto}
.clbl{font-size:8px;color:#ccc;letter-spacing:.5px;text-transform:uppercase;flex-shrink:0}
.sw{width:22px;height:22px;cursor:pointer;border:1.5px solid transparent;transition:transform .1s,border-color .1s;flex-shrink:0}
.sw:hover{transform:scale(1.18)}
.sw.on{border-color:#1a1a1a !important;transform:scale(1.1)}
.cusw{width:22px;height:22px;border:1.5px dashed #ccc;background:none;display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:14px;color:#ccc;flex-shrink:0;transition:all .12s}
.cusw:hover{border-color:#1a1a1a;color:#1a1a1a}
#cusci{display:none}

/* â”€â”€ SIZE PANEL â”€â”€ */
#spanel{position:fixed;left:calc(var(--lw) + var(--cw));top:var(--tb);bottom:0;width:var(--sw);background:#fafafa;border-right:1px solid #e8e8e8;display:flex;flex-direction:column;align-items:center;padding:10px 4px;z-index:130;gap:4px}
.slbl{font-size:8px;color:#ccc;letter-spacing:.5px;text-transform:uppercase}
.vsl{-webkit-appearance:none;appearance:none;writing-mode:vertical-lr;direction:rtl;width:3px;height:120px;background:#1a1a1a;outline:none;cursor:pointer;flex-shrink:0}
.vsl::-webkit-slider-thumb{-webkit-appearance:none;width:13px;height:13px;background:#fff;border:2px solid #1a1a1a;cursor:pointer;border-radius:0}
.sval{font-size:9px;color:#1a1a1a}
.sdiv{height:12px;flex-shrink:0}

/* â”€â”€ CANVAS AREA â”€â”€ */
/* The viewport: fixed, positioned after all panels */
#viewport{
  position:fixed;
  top:var(--tb);
  left:var(--left);
  right:0;
  bottom:0;
  overflow:hidden;
  cursor:crosshair;
}
/* The infinite canvas container that we pan/zoom by transforming */
#world{
  position:absolute;
  top:0; left:0;
  width:100%; height:100%;
  transform-origin:0 0;
  /* Grid rendered via CSS background â€” always correct, no sync needed */
  background-image:
    linear-gradient(to right, #cce4f7 1px, transparent 1px),
    linear-gradient(to bottom, #cce4f7 1px, transparent 1px);
  background-size:30px 30px;
}
/* The actual drawing canvas, same size as the infinite world we allow */
#wb{
  position:absolute;
  top:0; left:0;
  /* Canvas is large but transparent background so grid shows through */
}
/* Shape preview canvas â€” positioned in viewport space, NOT world space */
#prev{
  position:absolute;
  inset:0;
  pointer-events:none;
  display:none;
}
#text-ov{position:absolute;display:none;z-index:50}
#text-ta{border:1.5px dashed #888;background:rgba(255,255,255,.92);outline:none;resize:none;font-family:'DM Mono',monospace;font-size:16px;padding:4px 8px;min-width:120px;min-height:36px;color:#1a1a1a}

/* â”€â”€ BOARDS PANEL â”€â”€ */
#bpanel{position:fixed;right:0;top:var(--tb);bottom:0;width:220px;background:#fff;border-left:1.5px solid #1a1a1a;display:flex;flex-direction:column;z-index:160;transform:translateX(100%);transition:transform .22s}
#bpanel.open{transform:translateX(0)}
.bph{padding:14px;border-bottom:1px solid #ebebeb;font-size:11px;display:flex;align-items:center;justify-content:space-between;flex-shrink:0}
.blist{flex:1;overflow-y:auto;padding:6px}
.bitem{padding:9px 10px;border:1.5px solid transparent;cursor:pointer;display:flex;align-items:center;justify-content:space-between;margin-bottom:3px;transition:border-color .12s}
.bitem:hover{border-color:#ddd}
.bitem.on{border-color:#1a1a1a}
.biname{font-size:11px;flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.bidate{font-size:9px;color:#bbb;display:block}
.bidel{background:none;border:none;cursor:pointer;color:#ccc;padding:2px 4px;font-size:12px;margin-left:6px;flex-shrink:0;font-family:inherit}
.bidel:hover{color:#c00}
.nnbtn{margin:10px;padding:9px;background:none;border:1.5px dashed #e0e0e0;font-family:inherit;font-size:11px;cursor:pointer;color:#aaa;transition:all .15s}
.nnbtn:hover{border-color:#1a1a1a;color:#1a1a1a}

/* â”€â”€ SHORTCUTS MODAL â”€â”€ */
#skmod{position:fixed;inset:0;background:rgba(0,0,0,.4);display:none;align-items:center;justify-content:center;z-index:8000}
#skmod.open{display:flex}
.skbox{background:#fff;border:1.5px solid #1a1a1a;width:390px;max-height:80vh;overflow-y:auto;padding:28px}
.sktitle{font-size:13px;font-weight:500;margin-bottom:18px}
.skrow{display:flex;justify-content:space-between;padding:5px 0;border-bottom:1px solid #f2f2f2;font-size:11px}
.skk{background:#f5f5f5;border:1px solid #e0e0e0;padding:2px 7px;font-size:10px;color:#666;font-family:inherit}

/* â”€â”€ NOTIF â”€â”€ */
#notif{position:fixed;bottom:18px;left:50%;transform:translateX(-50%) translateY(70px);background:#1a1a1a;color:#fff;font-family:inherit;font-size:11px;padding:7px 18px;z-index:5000;transition:transform .25s;pointer-events:none;letter-spacing:.3px}
#notif.show{transform:translateX(-50%) translateY(0)}
</style>
</head>
<body>

<!-- AUTH -->
<div id="auth">
  <div class="abox">
    <div class="alogo">NoteGrid</div>
    <div class="atag">// free study whiteboard â€” saved locally, forever</div>
    <div class="atabs">
      <button class="atab on" onclick="switchTab('login',this)">Login</button>
      <button class="atab" onclick="switchTab('register',this)">Register</button>
    </div>
    <div id="lf">
      <div class="afield"><label>Username</label><input id="lu" type="text" autocomplete="username" onkeydown="if(event.key==='Enter')doLogin()"></div>
      <div class="afield"><label>Password</label><input id="lp" type="password" autocomplete="current-password" onkeydown="if(event.key==='Enter')doLogin()"></div>
      <button class="abtn" onclick="doLogin()">Sign In</button>
      <button class="askip" onclick="skipAuth()">Continue without account</button>
    </div>
    <div id="rf" style="display:none">
      <div class="afield"><label>Username</label><input id="ru" type="text" autocomplete="username"></div>
      <div class="afield"><label>Password</label><input id="rp" type="password" autocomplete="new-password"></div>
      <div class="afield"><label>Confirm</label><input id="rp2" type="password" autocomplete="new-password" onkeydown="if(event.key==='Enter')doRegister()"></div>
      <button class="abtn" onclick="doRegister()">Create Account</button>
      <button class="askip" onclick="skipAuth()">Continue without account</button>
    </div>
    <div class="aerr" id="aerr"></div>
  </div>
</div>

<!-- TOPBAR -->
<div id="topbar">
  <div class="logo">NoteGrid</div>
  <div class="sep"></div>
  <input class="bname" id="bname" value="Untitled Board">
  <div class="sep"></div>
  <button class="tbtn" onclick="newBoard()">ï¼‹ New</button>
  <button class="tbtn pri" onclick="saveBoard()">Save</button>
  <button class="tbtn" onclick="exportPNG()">Export PNG</button>
  <button class="tbtn" onclick="clearBoard()">Clear</button>
  <div class="sep"></div>
  <span style="font-size:9px;color:#aaa;flex-shrink:0">FILL:</span>
  <div class="fmodes">
    <button class="fmbtn on" id="fm-stroke" onclick="setFM('stroke',this)">Stroke</button>
    <button class="fmbtn" id="fm-fill" onclick="setFM('fill',this)">Fill</button>
    <button class="fmbtn" id="fm-both" onclick="setFM('both',this)">Both</button>
  </div>
  <div class="sp"></div>
  <button class="tbtn" onclick="doZoom(1/1.2)">âˆ’</button>
  <span class="zd" id="zd">100%</span>
  <button class="tbtn" onclick="doZoom(1.2)">ï¼‹</button>
  <button class="tbtn" onclick="resetView()">Reset</button>
  <div class="sep"></div>
  <button class="tbtn" onclick="toggleBoards()" id="btog">Boards â–¸</button>
  <div class="sep"></div>
  <button class="tbtn" onclick="document.getElementById('skmod').classList.toggle('open')">?</button>
  <div class="sep"></div>
  <span class="ubadge" id="ubadge">guest</span>
  <button class="tbtn" id="loutbtn" onclick="doLogout()" style="display:none">Logout</button>
</div>

<!-- LEFT TOOLBAR -->
<div id="toolbar">
  <button class="tb on" id="t-pen"         onclick="setTool('pen')">âœï¸<span class="tip">Pen [P]</span></button>
  <button class="tb"    id="t-highlighter" onclick="setTool('highlighter')" style="font-size:13px;letter-spacing:-1px">â–â–Œ<span class="tip">Highlighter [H]</span></button>
  <button class="tb"    id="t-eraser"      onclick="setTool('eraser')" style="font-size:13px">â—»<span class="tip">Eraser [E]</span></button>
  <div class="tsep"></div>
  <button class="tb" id="t-line"     onclick="setTool('line')"     style="font-size:13px">â•±<span class="tip">Line [L]</span></button>
  <button class="tb" id="t-rect"     onclick="setTool('rect')"     style="font-size:13px">â–¡<span class="tip">Rectangle [R]</span></button>
  <button class="tb" id="t-circle"   onclick="setTool('circle')"   style="font-size:13px">â—‹<span class="tip">Circle [C]</span></button>
  <button class="tb" id="t-triangle" onclick="setTool('triangle')" style="font-size:12px">â–³<span class="tip">Triangle [G]</span></button>
  <button class="tb" id="t-arrow"    onclick="setTool('arrow')"    style="font-size:13px">â†’<span class="tip">Arrow [A]</span></button>
  <div class="tsep"></div>
  <button class="tb" id="t-text"   onclick="setTool('text')"   style="font-size:15px">T<span class="tip">Text [T]</span></button>
  <button class="tb" id="t-sticky" onclick="addSticky()"       style="font-size:13px">ğŸ—’<span class="tip">Sticky [N]</span></button>
  <div class="tsep"></div>
  <button class="tb" id="t-pan" onclick="setTool('pan')" style="font-size:14px">âœ‹<span class="tip">Pan [Space / V]</span></button>
  <div class="tsep"></div>
  <button class="tb" onclick="undo()" style="font-size:14px">â†©<span class="tip">Undo [Ctrl+Z]</span></button>
  <button class="tb" onclick="redo()" style="font-size:14px">â†ª<span class="tip">Redo [Ctrl+Y]</span></button>
</div>

<!-- COLOR PANEL -->
<div id="cpanel">
  <div class="clbl">Color</div>
  <input type="color" id="cusci" onchange="pickColor(this.value)">
  <button class="cusw" onclick="document.getElementById('cusci').click()" title="Custom color">+</button>
  <!-- swatches injected by JS -->
</div>

<!-- SIZE PANEL -->
<div id="spanel">
  <div class="slbl">Sz</div>
  <input type="range" class="vsl" id="szsl" min="1" max="80" value="4" oninput="setSize(this.value)">
  <div class="sval" id="szval">4px</div>
  <div class="sdiv"></div>
  <div class="slbl">Op</div>
  <input type="range" class="vsl" id="opsl" min="5" max="100" value="100" oninput="setOp(this.value)">
  <div class="sval" id="opval">100%</div>
</div>

<!-- VIEWPORT -->
<div id="viewport">
  <!-- World: panned & zoomed container with CSS grid background -->
  <div id="world">
    <canvas id="wb"></canvas>
  </div>
  <!-- Shape preview drawn in screen/viewport space -->
  <canvas id="prev"></canvas>
  <!-- Text input overlay in screen space -->
  <div id="text-ov"><textarea id="text-ta" rows="3" placeholder="Typeâ€¦ Enter=commit  Shift+Enter=newline  Esc=cancel"></textarea></div>
</div>

<!-- BOARDS PANEL -->
<div id="bpanel">
  <div class="bph">
    <span>MY BOARDS</span>
    <button class="tb" style="width:24px;height:24px;font-size:13px" onclick="toggleBoards()">âœ•</button>
  </div>
  <div class="blist" id="blist"></div>
  <button class="nnbtn" onclick="newBoard()">ï¼‹ New Board</button>
</div>

<!-- SHORTCUTS MODAL -->
<div id="skmod">
  <div class="skbox">
    <div class="sktitle">Keyboard Shortcuts</div>
    <div class="skrow"><span>Pen</span><span class="skk">P</span></div>
    <div class="skrow"><span>Highlighter</span><span class="skk">H</span></div>
    <div class="skrow"><span>Eraser</span><span class="skk">E</span></div>
    <div class="skrow"><span>Line / Rect / Circle</span><span class="skk">L / R / C</span></div>
    <div class="skrow"><span>Triangle / Arrow</span><span class="skk">G / A</span></div>
    <div class="skrow"><span>Text</span><span class="skk">T</span></div>
    <div class="skrow"><span>Sticky Note</span><span class="skk">N</span></div>
    <div class="skrow"><span>Pan mode</span><span class="skk">V  or  hold Space</span></div>
    <div class="skrow"><span>Undo / Redo</span><span class="skk">Ctrl+Z / Ctrl+Y</span></div>
    <div class="skrow"><span>Zoom in / out</span><span class="skk">Ctrl+= / Ctrl+-</span></div>
    <div class="skrow"><span>Zoom with scroll</span><span class="skk">Ctrl + Scroll</span></div>
    <div class="skrow"><span>Reset view</span><span class="skk">Ctrl+0</span></div>
    <div class="skrow"><span>Save</span><span class="skk">Ctrl+S</span></div>
    <div class="skrow"><span>New Board</span><span class="skk">Ctrl+N</span></div>
    <div class="skrow"><span>Clear board</span><span class="skk">Ctrl+Shift+X</span></div>
    <div class="skrow"><span>Close / Cancel</span><span class="skk">Esc</span></div>
    <br>
    <button class="abtn" onclick="document.getElementById('skmod').classList.remove('open')">Close</button>
  </div>
</div>

<div id="notif"></div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CANVAS SETUP
// The drawing canvas (wb) is large and fixed â€” its top-left is
// always at world origin (0,0). We move the "world" div with CSS
// transform (translate + scale) for pan/zoom. Coordinates we
// receive from mouse events are viewport-relative; we convert them
// to canvas-space by reversing the transform: x_canvas = (x_vp - panX) / zoom.
//
// The CSS grid background on #world always stays aligned because
// background-size scales with the element.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const CANVAS_W = 6000, CANVAS_H = 5000;

// DOM
const VP   = document.getElementById('viewport');
const WORLD= document.getElementById('world');
const WB   = document.getElementById('wb');
const CTX  = WB.getContext('2d');
const PREV = document.getElementById('prev');
const PCTX = PREV.getContext('2d');

// State
let CU = null;            // current user (null = guest)
let boardId = null;
let tool = 'pen';
let color = '#1a1a1a';
let brushSz = 4;
let opac = 1.0;
let fillMode = 'stroke';

let zoom = 1, panX = 0, panY = 0;
let panning = false, spaceDown = false, prevPX = 0, prevPY = 0;
let drawing = false;
let lastCX = 0, lastCY = 0;   // last canvas-space coords while drawing freehand
let shapeAnchor = null;        // canvas-space start point for shapes

let undoStack = [], redoStack = [];
const MAX_UNDO = 60;

const PALETTE = [
  '#1a1a1a','#ffffff','#444444','#888888',
  '#cc0000','#e05a00','#cc8800','#1a7a1a',
  '#006699','#4b0082','#cc44aa','#8b4513',
  '#ffe066','#b4f0a0','#a0d8f0','#f0a0c8',
  '#ffd0a0','#d0b4ff','#ff6b6b','#4ecdc4'
];

// â”€â”€ INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function init() {
  WB.width  = CANVAS_W;
  WB.height = CANVAS_H;
  // canvas background is transparent so the grid div shows through
  // but we fill it white initially so drawings look right
  CTX.fillStyle = '#fff';
  CTX.fillRect(0, 0, CANVAS_W, CANVAS_H);

  resizePrev();
  window.addEventListener('resize', resizePrev);

  buildPalette();
  applyTransform();
  setupEvents();
  setupKeys();
  setupTextTool();
  autoLogin();
}

function resizePrev() {
  PREV.width  = VP.offsetWidth;
  PREV.height = VP.offsetHeight;
}

// â”€â”€ TRANSFORM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// We apply pan/zoom to the WORLD div via CSS transform.
// The canvas (WB) sits at top:0;left:0 inside WORLD.
function applyTransform() {
  WORLD.style.transform = `translate(${panX}px,${panY}px) scale(${zoom})`;
  document.getElementById('zd').textContent = Math.round(zoom * 100) + '%';
  // Update CSS grid cell size to stay visually consistent
  const gs = 30; // base grid size in canvas pixels; CSS background-size accounts for zoom
  // background-size is already handled by the transform on world â€” grid scales with it!
}

// Convert viewport-relative coords â†’ canvas-space coords
function vpToCanvas(vx, vy) {
  return { x: (vx - panX) / zoom, y: (vy - panY) / zoom };
}

// Convert viewport-relative coords (event) accounting for viewport offset
function evToVP(e) {
  const r = VP.getBoundingClientRect();
  return { x: e.clientX - r.left, y: e.clientY - r.top };
}

function evToCanvas(e) {
  const vp = evToVP(e);
  return vpToCanvas(vp.x, vp.y);
}

function doZoom(factor, cx, cy) {
  if (cx === undefined) { cx = VP.offsetWidth / 2; cy = VP.offsetHeight / 2; }
  const nz = Math.max(0.08, Math.min(10, zoom * factor));
  const r   = nz / zoom;
  panX = cx - (cx - panX) * r;
  panY = cy - (cy - panY) * r;
  zoom = nz;
  applyTransform();
}

function resetView() { zoom = 1; panX = 0; panY = 0; applyTransform(); }

// â”€â”€ PALETTE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildPalette() {
  const panel = document.getElementById('cpanel');
  // Remove old swatches (keep label, hidden input, custom button)
  [...panel.querySelectorAll('.sw')].forEach(s => s.remove());
  PALETTE.forEach(c => {
    const sw = document.createElement('div');
    sw.className = 'sw' + (c === color ? ' on' : '');
    sw.style.background = c;
    if (c === '#ffffff') sw.style.border = '1.5px solid #ccc';
    sw.addEventListener('click', () => {
      color = c;
      document.querySelectorAll('.sw').forEach(s => s.classList.remove('on'));
      sw.classList.add('on');
    });
    panel.appendChild(sw);
  });
}

function pickColor(c) {
  color = c;
  document.querySelectorAll('.sw').forEach(s => s.classList.remove('on'));
}

// â”€â”€ TOOLS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setTool(t) {
  tool = t;
  document.querySelectorAll('.tb[id^="t-"]').forEach(b => b.classList.remove('on'));
  const btn = document.getElementById('t-' + t);
  if (btn) btn.classList.add('on');
  VP.style.cursor = t === 'pan' ? 'grab' : t === 'eraser' ? 'cell' : t === 'text' ? 'text' : 'crosshair';
}

function setSize(v) { brushSz = +v; document.getElementById('szval').textContent = v + 'px'; }
function setOp(v)   { opac = v / 100; document.getElementById('opval').textContent = v + '%'; }
function setFM(m, btn) {
  fillMode = m;
  document.querySelectorAll('.fmbtn').forEach(b => b.classList.remove('on'));
  btn.classList.add('on');
}

// â”€â”€ DRAWING STYLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function applyStyle(c) {
  c.globalCompositeOperation = tool === 'eraser' ? 'destination-out' : 'source-over';
  if (tool === 'eraser') {
    c.globalAlpha = 1;
    c.strokeStyle = 'rgba(0,0,0,1)';
    c.fillStyle   = 'rgba(0,0,0,1)';
    c.lineWidth   = brushSz * 3;
    c.lineCap     = 'round';
    c.lineJoin    = 'round';
  } else if (tool === 'highlighter') {
    c.globalAlpha = 0.30;
    c.strokeStyle = color;
    c.fillStyle   = color;
    c.lineWidth   = brushSz * 5;
    c.lineCap     = 'square';
    c.lineJoin    = 'miter';
  } else {
    c.globalAlpha = opac;
    c.strokeStyle = color;
    c.fillStyle   = color;
    c.lineWidth   = brushSz;
    c.lineCap     = 'round';
    c.lineJoin    = 'round';
  }
}

// â”€â”€ SHAPE DRAWING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawShape(c, x1, y1, x2, y2, preview) {
  const savedTool = tool; // shapes in preview use current tool
  c.save();
  if (preview) {
    c.globalAlpha = opac * 0.85;
    c.strokeStyle = color;
    c.fillStyle   = color;
    c.lineWidth   = brushSz;
    c.lineCap     = 'round';
    c.lineJoin    = 'round';
    c.globalCompositeOperation = 'source-over';
  } else {
    applyStyle(c);
  }

  c.beginPath();
  if (tool === 'line') {
    c.moveTo(x1,y1); c.lineTo(x2,y2); c.stroke();
  } else if (tool === 'rect') {
    const [rx,ry,rw,rh] = [Math.min(x1,x2),Math.min(y1,y2),Math.abs(x2-x1),Math.abs(y2-y1)];
    c.rect(rx,ry,rw,rh);
    if (fillMode==='fill'||fillMode==='both') c.fill();
    if (fillMode==='stroke'||fillMode==='both') c.stroke();
  } else if (tool === 'circle') {
    const rx=(x2-x1)/2, ry=(y2-y1)/2, cx=x1+rx, cy=y1+ry;
    c.ellipse(cx,cy,Math.abs(rx),Math.abs(ry),0,0,Math.PI*2);
    if (fillMode==='fill'||fillMode==='both') c.fill();
    if (fillMode==='stroke'||fillMode==='both') c.stroke();
  } else if (tool === 'triangle') {
    c.moveTo((x1+x2)/2, y1); c.lineTo(x2,y2); c.lineTo(x1,y2); c.closePath();
    if (fillMode==='fill'||fillMode==='both') c.fill();
    if (fillMode==='stroke'||fillMode==='both') c.stroke();
  } else if (tool === 'arrow') {
    const ang = Math.atan2(y2-y1,x2-x1);
    const hl  = Math.min(24 + brushSz*2, Math.hypot(x2-x1,y2-y1)*0.4 + 4);
    c.moveTo(x1,y1); c.lineTo(x2,y2); c.stroke();
    c.beginPath();
    c.moveTo(x2,y2);
    c.lineTo(x2-hl*Math.cos(ang-.45), y2-hl*Math.sin(ang-.45));
    c.moveTo(x2,y2);
    c.lineTo(x2-hl*Math.cos(ang+.45), y2-hl*Math.sin(ang+.45));
    c.stroke();
  }
  c.restore();
}

// Shape preview: drawn on PREV canvas in viewport space, then transformed to match world
function drawShapePreview(vpX2, vpY2) {
  PCTX.clearRect(0, 0, PREV.width, PREV.height);
  if (!shapeAnchor) return;
  // Convert anchor (canvas space) back to viewport space for preview
  const ax = shapeAnchor.x * zoom + panX;
  const ay = shapeAnchor.y * zoom + panY;
  const bx = vpX2, by = vpY2;

  // Draw preview in canvas space scaled to viewport
  PCTX.save();
  PCTX.scale(zoom, zoom);
  PCTX.translate(panX / zoom, panY / zoom);
  drawShape(PCTX, shapeAnchor.x, shapeAnchor.y, (vpX2 - panX)/zoom, (vpY2 - panY)/zoom, true);
  PCTX.restore();
}

// â”€â”€ EVENTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setupEvents() {
  VP.addEventListener('mousedown',  onDown);
  VP.addEventListener('mousemove',  onMove);
  VP.addEventListener('mouseup',    onUp);
  VP.addEventListener('mouseleave', onUp);
  VP.addEventListener('wheel', onWheel, { passive: false });
  VP.addEventListener('touchstart', onTStart, { passive: false });
  VP.addEventListener('touchmove',  onTMove,  { passive: false });
  VP.addEventListener('touchend',   onTEnd);
  VP.addEventListener('contextmenu', e => e.preventDefault());
}

function onDown(e) {
  if (e.button !== 0) return;
  const vp = evToVP(e);
  const cv = vpToCanvas(vp.x, vp.y);

  if (spaceDown || tool === 'pan') {
    panning = true; prevPX = e.clientX; prevPY = e.clientY;
    VP.style.cursor = 'grabbing';
    return;
  }

  if (tool === 'text') { openText(cv, vp); return; }

  const shapeTools = ['line','rect','circle','triangle','arrow'];
  if (shapeTools.includes(tool)) {
    shapeAnchor = cv;
    drawing = true;
    PREV.style.display = 'block';
    return;
  }

  // Freehand (pen, highlighter, eraser)
  drawing = true;
  lastCX = cv.x; lastCY = cv.y;
  pushUndo();
  CTX.save(); applyStyle(CTX);
  CTX.beginPath();
  const r = tool === 'highlighter' ? brushSz * 2.5 : brushSz / 2;
  CTX.arc(cv.x, cv.y, Math.max(0.5, r), 0, Math.PI*2);
  CTX.fill();
  CTX.restore();
}

function onMove(e) {
  const vp = evToVP(e);
  const cv = vpToCanvas(vp.x, vp.y);

  if (panning) {
    panX += e.clientX - prevPX; panY += e.clientY - prevPY;
    prevPX = e.clientX; prevPY = e.clientY;
    applyTransform(); return;
  }
  if (!drawing) return;

  if (shapeAnchor) {
    drawShapePreview(vp.x, vp.y); return;
  }

  // Freehand
  CTX.save(); applyStyle(CTX);
  CTX.beginPath(); CTX.moveTo(lastCX, lastCY); CTX.lineTo(cv.x, cv.y); CTX.stroke();
  CTX.restore();
  lastCX = cv.x; lastCY = cv.y;
}

function onUp(e) {
  if (panning) {
    panning = false;
    VP.style.cursor = (tool === 'pan' || spaceDown) ? 'grab' : (tool === 'eraser' ? 'cell' : tool === 'text' ? 'text' : 'crosshair');
    return;
  }
  if (shapeAnchor && drawing) {
    const vp = evToVP(e);
    const cv = vpToCanvas(vp.x, vp.y);
    PCTX.clearRect(0, 0, PREV.width, PREV.height);
    PREV.style.display = 'none';
    pushUndo();
    CTX.save(); applyStyle(CTX);
    drawShape(CTX, shapeAnchor.x, shapeAnchor.y, cv.x, cv.y, false);
    CTX.restore();
    shapeAnchor = null;
  }
  drawing = false;
}

function onWheel(e) {
  e.preventDefault();
  if (e.ctrlKey || e.metaKey) {
    const vp = evToVP(e);
    doZoom(e.deltaY < 0 ? 1.1 : 0.9, vp.x, vp.y);
  } else {
    panX -= e.deltaX * 1.2;
    panY -= e.deltaY * 1.2;
    applyTransform();
  }
}

// Touch
let lastTD = null, lastTCX = 0, lastTCY = 0;
function onTStart(e) {
  e.preventDefault();
  if (e.touches.length === 2) {
    lastTD = Math.hypot(e.touches[1].clientX-e.touches[0].clientX, e.touches[1].clientY-e.touches[0].clientY);
    lastTCX = (e.touches[0].clientX+e.touches[1].clientX)/2;
    lastTCY = (e.touches[0].clientY+e.touches[1].clientY)/2;
    return;
  }
  onDown({ button:0, clientX:e.touches[0].clientX, clientY:e.touches[0].clientY });
}
function onTMove(e) {
  e.preventDefault();
  if (e.touches.length === 2) {
    const d = Math.hypot(e.touches[1].clientX-e.touches[0].clientX, e.touches[1].clientY-e.touches[0].clientY);
    const cx = (e.touches[0].clientX+e.touches[1].clientX)/2;
    const cy = (e.touches[0].clientY+e.touches[1].clientY)/2;
    if (lastTD) {
      const r = VP.getBoundingClientRect();
      doZoom(d/lastTD, cx-r.left, cy-r.top);
      panX += cx-lastTCX; panY += cy-lastTCY; applyTransform();
    }
    lastTD=d; lastTCX=cx; lastTCY=cy; return;
  }
  onMove({ clientX:e.touches[0].clientX, clientY:e.touches[0].clientY });
}
function onTEnd(e) { lastTD=null; onUp({ clientX:0, clientY:0 }); }

// â”€â”€ TEXT TOOL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let textCV = {x:0,y:0};
let commitPending = false;

function setupTextTool() {
  const ta = document.getElementById('text-ta');
  ta.addEventListener('keydown', e => {
    if (e.key === 'Escape') { commitText(false); e.preventDefault(); return; }
    if (e.key === 'Enter' && !e.shiftKey) { commitText(true); e.preventDefault(); }
  });
  // blur commits after small delay (lets button clicks fire first)
  ta.addEventListener('blur', () => { setTimeout(() => commitText(true), 200); });
}

function openText(cv, vp) {
  const ov = document.getElementById('text-ov');
  const ta = document.getElementById('text-ta');
  textCV = cv;
  ta.value = '';
  ta.style.fontSize = Math.max(10, brushSz * 3) + 'px';
  ta.style.color = color;
  ta.style.minWidth = '140px';
  ov.style.left = vp.x + 'px';
  ov.style.top  = vp.y + 'px';
  ov.style.display = 'block';
  commitPending = false;
  requestAnimationFrame(() => ta.focus());
}

function commitText(save) {
  if (commitPending) return;
  commitPending = true;
  const ov = document.getElementById('text-ov');
  const ta = document.getElementById('text-ta');
  if (ov.style.display === 'none') { commitPending = false; return; }
  if (save && ta.value.trim()) {
    pushUndo();
    const fs = Math.max(10, brushSz * 3);
    CTX.save();
    CTX.globalAlpha = opac;
    CTX.globalCompositeOperation = 'source-over';
    CTX.fillStyle = color;
    CTX.font = `${fs}px 'DM Mono', monospace`;
    CTX.textBaseline = 'top';
    ta.value.split('\n').forEach((line, i) => {
      CTX.fillText(line, textCV.x, textCV.y + i * fs * 1.35);
    });
    CTX.restore();
  }
  ov.style.display = 'none';
  commitPending = false;
}

// â”€â”€ STICKY NOTES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function addSticky() {
  pushUndo();
  // Place at center of current view
  const cx = (-panX + VP.offsetWidth/2)  / zoom;
  const cy = (-panY + VP.offsetHeight/2) / zoom;
  const W=220, H=170, x=cx-W/2, y=cy-H/2;
  const bgs=['#ffe066','#b4f0a0','#a0d8f0','#f0a0c8','#ffd0a0','#d0b4ff'];
  const bg = bgs[Math.floor(Math.random()*bgs.length)];
  CTX.save();
  CTX.shadowColor='rgba(0,0,0,.15)'; CTX.shadowBlur=12; CTX.shadowOffsetX=2; CTX.shadowOffsetY=4;
  CTX.fillStyle=bg; CTX.fillRect(x,y,W,H);
  CTX.shadowColor='transparent';
  CTX.fillStyle='rgba(0,0,0,.07)'; CTX.fillRect(x,y,W,26);
  CTX.strokeStyle='rgba(0,0,0,.1)'; CTX.lineWidth=1;
  for(let i=1;i<6;i++){CTX.beginPath();CTX.moveTo(x+10,y+26+i*24);CTX.lineTo(x+W-10,y+26+i*24);CTX.stroke();}
  CTX.fillStyle='rgba(0,0,0,.3)'; CTX.font='500 11px DM Mono,monospace'; CTX.textBaseline='middle';
  CTX.fillText('âœ  Note', x+8, y+13);
  CTX.restore();
  showNotif('Sticky note added â€” use the Text tool to write on it!');
}

// â”€â”€ UNDO/REDO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function pushUndo() {
  undoStack.push(WB.toDataURL());
  if (undoStack.length > MAX_UNDO) undoStack.shift();
  redoStack = [];
}
function undo() {
  if (undoStack.length <= 1) return;
  redoStack.push(undoStack.pop());
  restoreSnap(undoStack[undoStack.length-1]);
}
function redo() {
  if (!redoStack.length) return;
  const sn = redoStack.pop(); undoStack.push(sn); restoreSnap(sn);
}
function restoreSnap(dataURL) {
  const img = new Image();
  img.onload = () => { CTX.fillStyle='#fff'; CTX.fillRect(0,0,CANVAS_W,CANVAS_H); CTX.drawImage(img,0,0); };
  img.src = dataURL;
}

// â”€â”€ KEYBOARD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setupKeys() {
  document.addEventListener('keydown', e => {
    const tag = document.activeElement.tagName;
    if (tag==='INPUT'||tag==='TEXTAREA') { if(e.key==='Escape') commitText(false); return; }
    if (e.key===' ') { e.preventDefault(); if(!spaceDown){spaceDown=true; VP.style.cursor='grab';} return; }
    if (e.key==='Escape') { document.getElementById('skmod').classList.remove('open'); commitText(false); return; }
    if (e.ctrlKey||e.metaKey) {
      if      (e.key==='z')                      { e.preventDefault(); undo(); }
      else if (e.key==='y'||(e.shiftKey&&e.key==='Z')) { e.preventDefault(); redo(); }
      else if (e.key==='s')                      { e.preventDefault(); saveBoard(); }
      else if (e.key==='n')                      { e.preventDefault(); newBoard(); }
      else if (e.key==='='||e.key==='+')         { e.preventDefault(); doZoom(1.2); }
      else if (e.key==='-')                      { e.preventDefault(); doZoom(1/1.2); }
      else if (e.key==='0')                      { e.preventDefault(); resetView(); }
      else if (e.shiftKey&&e.key==='X')          { e.preventDefault(); clearBoard(); }
      return;
    }
    const map={p:'pen',h:'highlighter',e:'eraser',l:'line',r:'rect',c:'circle',g:'triangle',a:'arrow',t:'text',n:'sticky',v:'pan'};
    const k = e.key.toLowerCase();
    if (map[k]) { map[k]==='sticky' ? addSticky() : setTool(map[k]); }
  });
  document.addEventListener('keyup', e => {
    if (e.key===' ') { spaceDown=false; VP.style.cursor = tool==='pan'?'grab': tool==='eraser'?'cell': tool==='text'?'text':'crosshair'; }
  });
}

// â”€â”€ AUTH â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getUsers() { return JSON.parse(localStorage.getItem('ng_users')||'{}'); }
function setUsers(u){ localStorage.setItem('ng_users',JSON.stringify(u)); }

function autoLogin() {
  const s = localStorage.getItem('ng_sess');
  if (s) { try { CU=JSON.parse(s).u; afterLogin(); } catch(e){ showAuth(); } }
  else showAuth();
}
function showAuth(){ document.getElementById('auth').style.display='flex'; }

function afterLogin() {
  document.getElementById('auth').style.display = 'none';
  document.getElementById('ubadge').textContent = CU || 'guest';
  document.getElementById('loutbtn').style.display = CU ? '' : 'none';
  loadSession(); renderBoards();
}

function switchTab(tab, btn) {
  document.querySelectorAll('.atab').forEach(t=>t.classList.remove('on')); btn.classList.add('on');
  document.getElementById('lf').style.display = tab==='login'?'':'none';
  document.getElementById('rf').style.display = tab==='register'?'':'none';
  document.getElementById('aerr').textContent='';
}
function doLogin() {
  const u=document.getElementById('lu').value.trim(), p=document.getElementById('lp').value;
  const users=getUsers();
  if(!users[u]||users[u].ph!==btoa(p)){document.getElementById('aerr').textContent='Invalid credentials.';return;}
  CU=u; localStorage.setItem('ng_sess',JSON.stringify({u})); afterLogin();
}
function doRegister() {
  const u=document.getElementById('ru').value.trim(), p=document.getElementById('rp').value, p2=document.getElementById('rp2').value;
  const err=document.getElementById('aerr');
  if(!u||!p){err.textContent='Fill all fields.';return;}
  if(p!==p2){err.textContent='Passwords do not match.';return;}
  const users=getUsers();
  if(users[u]){err.textContent='Username taken.';return;}
  users[u]={ph:btoa(p),boards:[]};setUsers(users);
  CU=u; localStorage.setItem('ng_sess',JSON.stringify({u})); afterLogin();
}
function skipAuth(){ CU=null; afterLogin(); }
function doLogout(){
  CU=null; localStorage.removeItem('ng_sess');
  document.getElementById('ubadge').textContent='guest';
  document.getElementById('loutbtn').style.display='none';
  boardId=null; clearCanvas(); undoStack=[]; redoStack=[];
  renderBoards(); showAuth();
}

// â”€â”€ BOARDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getBoards(){
  if(!CU) return JSON.parse(localStorage.getItem('ng_guest_boards')||'[]');
  const u=getUsers(); return (u[CU]&&u[CU].boards)||[];
}
function setBoards(b){
  if(!CU){localStorage.setItem('ng_guest_boards',JSON.stringify(b));return;}
  const u=getUsers(); if(u[CU])u[CU].boards=b; setUsers(u);
}
function lastKey(){ return CU?`ng_last_${CU}`:'ng_last_guest'; }

function loadSession(){
  const id=localStorage.getItem(lastKey());
  if(id){boardId=id; loadBoard(id);}else newBoard(false);
}

function newBoard(notify=true){
  if(boardId) autoSave();
  boardId='b_'+Date.now();
  const boards=getBoards();
  boards.unshift({id:boardId,name:'Untitled Board',date:todayStr()});
  setBoards(boards);
  document.getElementById('bname').value='Untitled Board';
  clearCanvas(); undoStack=[]; pushUndo();
  localStorage.setItem(lastKey(), boardId);
  renderBoards();
  if(notify) showNotif('New board created');
}

function switchBoard(id){
  autoSave(); boardId=id; loadBoard(id);
  localStorage.setItem(lastKey(), id);
  renderBoards();
}

function loadBoard(id){
  const boards=getBoards(), meta=boards.find(b=>b.id===id);
  if(meta) document.getElementById('bname').value=meta.name;
  const data=localStorage.getItem('ng_data_'+id);
  if(data){
    const img=new Image();
    img.onload=()=>{ CTX.fillStyle='#fff'; CTX.fillRect(0,0,CANVAS_W,CANVAS_H); CTX.drawImage(img,0,0); undoStack=[]; pushUndo(); };
    img.src=data;
  } else { clearCanvas(); undoStack=[]; pushUndo(); }
}

function saveBoard(){
  const name=document.getElementById('bname').value.trim()||'Untitled Board';
  const boards=getBoards(); const i=boards.findIndex(b=>b.id===boardId);
  if(i===-1) boards.unshift({id:boardId,name,date:todayStr()});
  else { boards[i].name=name; boards[i].date=todayStr(); }
  setBoards(boards);
  localStorage.setItem('ng_data_'+boardId, WB.toDataURL('image/png'));
  renderBoards(); showNotif('Saved âœ“');
}

function autoSave(){
  if(!boardId) return;
  const name=document.getElementById('bname').value.trim()||'Untitled Board';
  const boards=getBoards(); const i=boards.findIndex(b=>b.id===boardId);
  if(i!==-1){boards[i].name=name;boards[i].date=todayStr();setBoards(boards);}
  try{ localStorage.setItem('ng_data_'+boardId, WB.toDataURL('image/png')); }catch(e){}
}

function deleteBoard(id,e){
  e.stopPropagation();
  let boards=getBoards(); boards=boards.filter(b=>b.id!==id); setBoards(boards);
  localStorage.removeItem('ng_data_'+id);
  if(id===boardId){ boardId=null; clearCanvas(); undoStack=[]; newBoard(false); }
  renderBoards(); showNotif('Board deleted');
}

function clearBoard(){ if(!confirm('Clear this board?')) return; pushUndo(); clearCanvas(); showNotif('Cleared'); }
function clearCanvas(){ CTX.fillStyle='#fff'; CTX.fillRect(0,0,CANVAS_W,CANVAS_H); }

function exportPNG(){
  const a=document.createElement('a');
  a.download=(document.getElementById('bname').value||'board')+'.png';
  a.href=WB.toDataURL('image/png'); a.click(); showNotif('Exported PNG');
}

function renderBoards(){
  const boards=getBoards(), list=document.getElementById('blist');
  list.innerHTML='';
  boards.forEach(b=>{
    const d=document.createElement('div');
    d.className='bitem'+(b.id===boardId?' on':'');
    d.innerHTML=`<div style="flex:1;overflow:hidden"><div class="biname">${esc(b.name)}</div><span class="bidate">${b.date||''}</span></div><button class="bidel" data-id="${b.id}">âœ•</button>`;
    d.querySelector('.bidel').addEventListener('click', ev=>deleteBoard(b.id,ev));
    d.addEventListener('click', ev=>{ if(!ev.target.classList.contains('bidel')) switchBoard(b.id); });
    list.appendChild(d);
  });
}

function toggleBoards(){
  const p=document.getElementById('bpanel'); p.classList.toggle('open');
  document.getElementById('btog').textContent=p.classList.contains('open')?'Boards âœ•':'Boards â–¸';
  renderBoards();
}

// â”€â”€ UTILS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function esc(s){ return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function todayStr(){ return new Date().toLocaleDateString(); }

function showNotif(msg){
  const el=document.getElementById('notif');
  el.textContent=msg; el.classList.add('show');
  clearTimeout(el._t); el._t=setTimeout(()=>el.classList.remove('show'),2500);
}

// Auto-save every 60s
setInterval(()=>{ if(boardId) autoSave(); }, 60000);

// â”€â”€ START â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
init();
</script>
</body>
</html>
